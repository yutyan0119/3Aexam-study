# 分散システムまとめ

# 第1回
- クライアントサーバーシステムの欠点
  - サーバーへの負荷が大きい
  - サーバーから遠いと遅い
  - ネットワークへの負荷が集中

- CDN
  - サーバーを地理的に分散させる
    - 負荷減少
    - スループット向上
    - 負荷分散

- 人検知モデルのデータベース記録
  - 画像を送信してサーバーで検知
    - トラフィック多
    - 画質を下げると検知率低下
  - 検知をカメラ内で行って有無を送信
    - トラフィック少
    - 良い検知性能

# 第2回

- データの集合（DataSet）
  - Query
    - データの検索
- dataとqueryの関係
  - $R=QD=DQ$
    - DBMSはDに対してQを投げるとQDが得られる
      - 普通の検索
    - DSMS(DataStream Management System)はQに対してDを投げるとDQが得られる
      - メールの迷惑フィルタ・ラジオなど


# 第3回

- ネットワークとルーティング
  - 逐次法
    - 1つずつqueryと一致するか確かめる
  - 二分木
  
  - 実際のネットワーク
    - 複数のリンクがルータに繋がっている
    - 上下関係を持たない場合もある
    - グラフの中に閉路がある

- 経路の広告とパケットの配送
  - ノードからメッセージを送るように広告が来る
    - 発生するパケットが送られてくる

- Content Based PubSub Network
  - 欲しいコンテンツの条件をネットワークに登録すると、マッチするデータが送られてくるネットワークシステム

# 第4回(TCP/IP)

ホストA上に実装された関数をホストXから呼び出したい。

**Remote Procedure Call/RPC**あるいは**Remote Method Invocation/RMI**と呼ぶ。

ホスト間のメッセージの構造とデータ単位

| メッセージヘッダ | メッセージの交換に必要な情報（Content長/種類など） |
| ---------------- | -------------------------------------------------- |
| メッセージ本体   | 本体                                               |

アプリケーション間でやり取りされるデータ単位をApplication Protocol Data Unit (APDU)

以下の性質を持つ通信路が必要
1. APDUが届いたことを確認できる通信路
2. APDUが壊れないことを保証する通信路
   1. 順番が入れ替わらない
   2. 欠損しない
   3. 重複しない
3. 他者の通信に極端なダメージを与えず、適切なスループットを提供する

→TCPの役割がコレ

APDU -> TPDU(TCP/UDP) -> NPDU(IP) -> DPDU(MAC)

## 層アーキテクチャ
| 人                 |          | 人                 |
| ------------------ | -------- | ------------------ |
| Interface          |          | Interface          |
| アプリケーション層 | Protocol | アプリケーション層 |
| Interface          |          | Interface          |
| トランスポート層   | Protocol | トランスポート層   |
| Interface          |          | Interface          |
| データリンク層     |          | データリンク層     |
| Interface          |          | Interface          |
| 物理層             |          | 物理層             |

※TCP…順序性・信頼性を追加する
※IP…1500Byte程度に分割されたパケットをベストエフォートで届ける

# 第5/6回(Load Balancing)

クライアント・サーバーモデルでサーバーの処理能力が追いつかなくなってきたときの対処法
1. サーバーのプログラムや設定を見直す
2. 高価なサーバーに交換（スケールアップ）
3. サーバーを増設する（スケールアウト）

## Scale up VS Scale out

| Scale up                     | Scale out(例：ラウンドロビン)        |
| ---------------------------- | ------------------------------------ |
| 単純                         | 複雑で、処理振り分けの仕組みが必要   |
| 急激に高価になることがある   | 結果的に安価なこともある             |
| 数百倍の性能向上は見込めない | 必要に応じてシステム規模を変更できる |
|                              | 耐障害性をもたせやすい               |

ラウンドロビンは、どのサーバーでリクエストが処理されても良い場合の負荷分散に用いる。
NAPT + ロードバランサー（ラウンドロビン）で、ネットワーク層＋トランスポート層の負荷を分散する。（IP/TCPのdestinationをラウンドロビンでNAPTが変えていく）

## 広域負荷分散

例 `www.example.org` に対するリクエスト
ドメインに対してIPアドレスを複数登録しておく。
DNSにはインテリジェンスを持たせてクライアントの近くのサーバーを応答できるようにする（推定RTT/Round Trip Time）

## 大量のIDを管理するシステムの負荷分散
例：銀行口座

ポイント
1. 口座の内容は書き換えられる
2. 同一口座の内容を複数のコンピュータに分散させると、更新の管理が大変

⇨ 名前空間を分割して複数のコンピュータに分けて役割分担を明確にし、大規模化に対応する。

# 第7回（レプリケーション・一貫性・同期）

## レプリケーション
あるホストMのレプリカを他のホスト上に作ること。

負荷分散、耐障害性向上のために行われる。

## 一貫性
どのホストのデータにアクセスしても同じ内容が得られる状態

## 同期
一貫性を満たすようにすること

1. 処理が発生
2. ホスト間のトラフィックが発生
3. 遅延が発生

## 同期の種類
1. 更新通知方式
   1. MainにSubの宛先を設定しておく
   2. 更新したらSubに送信
2. Callback方式
   1. SubがMainに自分の場所を登録
   2. Mainは情報に基づいて更新を送信
3. ポーリング方式
   1. Subが定期的にMainに最新データを取りに行く
4. オンデマンド方式
   1. Subが最新データを必要としたときにMainに取りに行く
      1. Subに有効なデータ（キャッシュ）があれば取りに行かない
      2. Subに有効なデータがなければ取りに行く

### 各種法の特徴
- 更新通知・Callback方式
  - 更新時の処理が大きい
  - 同時に対応できるSubの数も少ない
  - レプリカ一貫性は良い
  - 更新頻度が増えるとネットワーク負荷が増える
- ポーリング方式
  - ポーリング周期が短いとき
    - 反映までの時間が短い
    - 負荷大
  - 長いとき
    - 反映までの時間が長い
    - 負荷が小さい
  - 各subのポーリングのタイミングが重ならなければSubの数を増やせる
- オンデマンド方式
  - Mainの負荷はばらけるのでSubは増やせる
  - キャッシュが利用されるので負荷が小さい

## 大規模一貫性の追求と同期の限界
大規模一貫性とは、ホスト数が大きくなったときの一貫性
1. オンデマンド方式
   - cacheの有効時間 -> 0
   - ユーザーからのリクエストがSubを通じてすべてMainへ行く（1台運用と変わらない）

2. ポーリング方式
   - 周期 -> 0
   - DDoSと同じ状況に

3. 更新通知・Callback方式
   - Sub -> 大
     - 更新時のMainの処理・ネットワーク負荷大
     - Subの多段構成による階層化
       - 伝搬遅延大

※ **結果整合性 (Eventual Consistency)**
データに瞬間的には一貫性が保証されないことを認めて、時間が経って結果的に一貫性が保たれている状態になれば良いとする大規模システム設計上の考え方

Basically Available, Softstate, Eventual Consistency (BASE) NoSQL

Atomicity, Consistency, Isolation, Durability (ACID) SQL

# 第8回 (インターフェスと実装)
システムは複数のパーツを統合することで作られる
システム化に取って重要なことは
1. パーツとパーツが結合できること
2. パーツ同士でメッセージの交換ができること

さらに、
1. パーツはインタフェースを通じて外界と通信する
   1. 通信によって自らの機能を提供
   2. 通信によって他者の機能を利用
2. 実装はブラックボックス化されていて内部にアクセス負荷

という特徴がある。

## 実装の自由と多様性・多相性（Polymorphism）

要求に適切に応答すればやり方は問わない

具体的な動作は選ばれた実装によって異なる(Polymorphism)

# 第9回 (プロキシ)

プロキシとは、あるホストあるいは、任意のホストの代理として働くアプリケーション層の機能
以下の目的で使われる。
1. 通信の低遅延・高速化
   1. サーバーのコンテンツをプロキシに持たせておけば高速になる
2. コンテンツの検閲・フィルタリング
   1. プロキシを通るリクエストの内容・レスポンスの内容を検閲する
3. コンテンツの加工
   1. オリジナルデータを圧縮したり別の表現に変換したりする
4. 通信端点の移動
   1. 特定のIPアドレス範囲からのリクエストにしか応答しないサーバーに対して、プロキシを利用することで、クライアントはサーバーと通信できるようになる
5. アドレスの秘匿化
   1. サーバーから見てクライアントのアドレスがわからなくなる（悪用もできる）
6. 負荷分散
   1. キャッシュでサーバーへのリクエストが減る
   2. プロキシでリクエストを振り分けて負荷分散できる

クライアントとサーバーの間に入って、プロキシを介して通信を行う。

透過プロキシ（クライアントとサーバーの間で透過的に振る舞う）※HTTPSでは動作しない

# 第10回（耐障害性）
Fault Tolerance
耐障害性を上げる基本的な考え方⇨単一障害点をなくす

## 冗長化
単一障害点となりうる箇所に対して同じものを1つあるいは2つ用意する

故障時の切り替え（信頼性）＆保守時の切り替え（可用性）

### 信頼性
障害によってサービスが停止しない度合いのこと
Redundancyを上げることで信頼性を上げることができる

### 可用性
サービスを利用したいときに利用できる度合いのこと
保守時に停止しないようにしたりする

## 耐障害性とセキュリティ
セキュリティ対策は悪意ある攻撃への対策 -> 冗長化で対策負荷
障害対応は起きうる故障への対策 -> 冗長化で対応

## 広域障害
冗長化すれば安心は間違い。

広く分散・同じ場所に置かない

# 第11回（コードマイグレーション）

- プロセスマイグレーション
- モバイエルエージェント

を含めた概念

分散システム上でプログラムを移動させて実行させることを言う。

## メリデメ
1. 応答性の向上
   - ユーザーに近いところでリクエストに応えると応答がスムーズ
2. 自律性の向上
   - 処理を集約させると自律性が上がる
3. プロトコル等の解決
   - アクセス方法をプログラムとして提供することで独自の通信プロトコルに対応できる
4. 処理速度の向上
   - データに近いところにプログラムを移動させると処理速度が上がる（レイテンシ？）
5. デバッグ及び例外処理は難しい
   - 不具合の記録を集めてくる仕組みが必要
   - 実行環境も色々
6. セキュリティのリスクがある
   - 実行したプログラムに悪意があれば、攻撃を受ける可能性がある

## プログラムに与える権限・資源
- 必要最小限の権限・資源を与える
