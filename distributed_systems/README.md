# 分散システムまとめ

# 第1回
- クライアントサーバーシステムの欠点
  - サーバーへの負荷が大きい
  - サーバーから遠いと遅い
  - ネットワークへの負荷が集中

- CDN
  - サーバーを地理的に分散させる
    - 負荷減少
    - スループット向上
    - 負荷分散

- 人検知モデルのデータベース記録
  - 画像を送信してサーバーで検知
    - トラフィック多
    - 画質を下げると検知率低下
  - 検知をカメラ内で行って有無を送信
    - トラフィック少
    - 良い検知性能

# 第2回

- データの集合（DataSet）
  - Query
    - データの検索
- dataとqueryの関係
  - $R=QD=DQ$
    - DBMSはDに対してQを投げるとQDが得られる
      - 普通の検索
    - DSMS(DataStream Management System)はQに対してDを投げるとDQが得られる
      - メールの迷惑フィルタ・ラジオなど


# 第3回

- ネットワークとルーティング
  - 逐次法
    - 1つずつqueryと一致するか確かめる
  - 二分木
  
  - 実際のネットワーク
    - 複数のリンクがルータに繋がっている
    - 上下関係を持たない場合もある
    - グラフの中に閉路がある

- 経路の広告とパケットの配送
  - ノードからメッセージを送るように広告が来る
    - 発生するパケットが送られてくる

- Content Based PubSub Network
  - 欲しいコンテンツの条件をネットワークに登録すると、マッチするデータが送られてくるネットワークシステム

# 第4回(TCP/IP)

ホストA上に実装された関数をホストXから呼び出したい。

**Remote Procedure Call/RPC**あるいは**Remote Method Invocation/RMI**と呼ぶ。

ホスト間のメッセージの構造とデータ単位

| メッセージヘッダ | メッセージの交換に必要な情報（Content長/種類など） |
| ---------------- | -------------------------------------------------- |
| メッセージ本体   | 本体                                               |

アプリケーション間でやり取りされるデータ単位をApplication Protocol Data Unit (APDU)

以下の性質を持つ通信路が必要
1. APDUが届いたことを確認できる通信路
2. APDUが壊れないことを保証する通信路
   1. 順番が入れ替わらない
   2. 欠損しない
   3. 重複しない
3. 他者の通信に極端なダメージを与えず、適切なスループットを提供する

→TCPの役割がコレ

APDU -> TPDU(TCP/UDP) -> NPDU(IP) -> DPDU(MAC)

## 層アーキテクチャ
| 人                 |          | 人                 |
| ------------------ | -------- | ------------------ |
| Interface          |          | Interface          |
| アプリケーション層 | Protocol | アプリケーション層 |
| Interface          |          | Interface          |
| トランスポート層   | Protocol | トランスポート層   |
| Interface          |          | Interface          |
| データリンク層     |          | データリンク層     |
| Interface          |          | Interface          |
| 物理層             |          | 物理層             |

※TCP…順序性・信頼性を追加する
※IP…1500Byte程度に分割されたパケットをベストエフォートで届ける

# 第5/6回(Load Balancing)

クライアント・サーバーモデルでサーバーの処理能力が追いつかなくなってきたときの対処法
1. サーバーのプログラムや設定を見直す
2. 高価なサーバーに交換（スケールアップ）
3. サーバーを増設する（スケールアウト）

## Scale up VS Scale out

| Scale up                     | Scale out(例：ラウンドロビン)        |
| ---------------------------- | ------------------------------------ |
| 単純                         | 複雑で、処理振り分けの仕組みが必要   |
| 急激に高価になることがある   | 結果的に安価なこともある             |
| 数百倍の性能向上は見込めない | 必要に応じてシステム規模を変更できる |
|                              | 耐障害性をもたせやすい               |

ラウンドロビンは、どのサーバーでリクエストが処理されても良い場合の負荷分散に用いる。
NAPT + ロードバランサー（ラウンドロビン）で、ネットワーク層＋トランスポート層の負荷を分散する。（IP/TCPのdestinationをラウンドロビンでNAPTが変えていく）

## 広域負荷分散

例 `www.example.org` に対するリクエスト
ドメインに対してIPアドレスを複数登録しておく。
DNSにはインテリジェンスを持たせてクライアントの近くのサーバーを応答できるようにする（推定RTT/Round Trip Time）

## 大量のIDを管理するシステムの負荷分散
例：銀行口座

ポイント
1. 口座の内容は書き換えられる
2. 同一口座の内容を複数のコンピュータに分散させると、更新の管理が大変

⇨ 名前空間を分割して複数のコンピュータに分けて役割分担を明確にし、大規模化に対応する。

# 第7回（レプリケーション・一貫性・同期）

## レプリケーション
あるホストMのレプリカを他のホスト上に作ること。

負荷分散、耐障害性向上のために行われる。

## 一貫性
どのホストのデータにアクセスしても同じ内容が得られる状態

## 同期
一貫性を満たすようにすること

1. 処理が発生
2. ホスト間のトラフィックが発生
3. 遅延が発生

## 同期の種類
1. 更新通知方式
   1. MainにSubの宛先を設定しておく
   2. 更新したらSubに送信
2. Callback方式
   1. SubがMainに自分の場所を登録
   2. Mainは情報に基づいて更新を送信
3. ポーリング方式
   1. Subが定期的にMainに最新データを取りに行く
4. オンデマンド方式
   1. Subが最新データを必要としたときにMainに取りに行く
      1. Subに有効なデータ（キャッシュ）があれば取りに行かない
      2. Subに有効なデータがなければ取りに行く

### 各種法の特徴
- 更新通知・Callback方式
  - 更新時の処理が大きい
  - 同時に対応できるSubの数も少ない
  - レプリカ一貫性は良い
  - 更新頻度が増えるとネットワーク負荷が増える
- ポーリング方式
  - ポーリング周期が短いとき
    - 反映までの時間が短い
    - 負荷大
  - 長いとき
    - 反映までの時間が長い
    - 負荷が小さい
  - 各subのポーリングのタイミングが重ならなければSubの数を増やせる
- オンデマンド方式
  - Mainの負荷はばらけるのでSubは増やせる
  - キャッシュが利用されるので負荷が小さい

## 大規模一貫性の追求と同期の限界
大規模一貫性とは、ホスト数が大きくなったときの一貫性
1. オンデマンド方式
   - cacheの有効時間 -> 0
   - ユーザーからのリクエストがSubを通じてすべてMainへ行く（1台運用と変わらない）

2. ポーリング方式
   - 周期 -> 0
   - DDoSと同じ状況に

3. 更新通知・Callback方式
   - Sub -> 大
     - 更新時のMainの処理・ネットワーク負荷大
     - Subの多段構成による階層化
       - 伝搬遅延大

※ **結果整合性 (Eventual Consistency)**
データに瞬間的には一貫性が保証されないことを認めて、時間が経って結果的に一貫性が保たれている状態になれば良いとする大規模システム設計上の考え方

Basically Available, Softstate, Eventual Consistency (BASE) NoSQL

Atomicity, Consistency, Isolation, Durability (ACID) SQL

